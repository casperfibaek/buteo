<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>buteo.raster.reproject API documentation</title>
<meta name="description" content="Reproject rasters. ### …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buteo.raster.reproject</code></h1>
</header>
<section id="section-intro">
<h3 id="reproject-rasters">Reproject rasters.</h3>
<p>Module to reproject rasters to a target coordinate reference system.
Can uses references from vector or other raster datasets.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
### Reproject rasters. ###

Module to reproject rasters to a target coordinate reference system.
Can uses references from vector or other raster datasets.
&#34;&#34;&#34;

# Standard library
import sys; sys.path.append(&#34;../../&#34;)
from typing import Union, Optional, List

# External
from osgeo import gdal, ogr, osr

# Internal
from buteo.utils import core_utils, gdal_utils, gdal_enums
from buteo.raster import core_raster


def find_common_projection(
    rasters: Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]],
):
    &#34;&#34;&#34;
        Find the common projection of a list of rasters. If no rasters have 
        the majority of the same projection, the function will return the
        projection of the first raster. If only on raster is provided, the
        projection of that raster will be returned.
    
        Args:
            rasters (list): A list of rasters.

        Returns:
            osr.SpatialReference: The common projection.
    &#34;&#34;&#34;
    core_utils.type_check(rasters, [str, gdal.Dataset, [str, gdal.Dataset]], &#34;rasters&#34;)

    rasters = core_utils.ensure_list(rasters)

    assert gdal_utils.is_raster_list(rasters), &#34;rasters must be a list of rasters.&#34;

    # Get the projection of each raster
    projections = [gdal_utils.parse_projection(raster) for raster in rasters]

    # Get the most common projection
    common_projection = max(set(projections), key=projections.count)

    return common_projection


def _reproject_raster(
    raster,
    projection,
    out_path=None,
    *,
    resample_alg=&#34;nearest&#34;,
    copy_if_same=True,
    overwrite=True,
    creation_options=None,
    dst_nodata=&#34;infer&#34;,
    dtype=None,
    prefix=&#34;&#34;,
    suffix=&#34;&#34;,
    add_uuid=False,
):
    &#34;&#34;&#34; Internal. &#34;&#34;&#34;
    assert isinstance(raster, (gdal.Dataset, str)), f&#34;The input raster must be in the form of a str or a gdal.Dataset: {raster}&#34;

    out_path = gdal_utils.create_output_path(
        raster,
        out_path=out_path,
        overwrite=overwrite,
        prefix=prefix,
        suffix=suffix,
        add_uuid=add_uuid,
    )

    ref = core_raster._open_raster(raster)
    metadata = core_raster._raster_to_metadata(ref)

    out_format = gdal_utils.path_to_driver_raster(out_path)

    original_projection = gdal_utils.parse_projection(ref)
    target_projection = gdal_utils.parse_projection(projection)

    if not isinstance(original_projection, osr.SpatialReference):
        raise RuntimeError(&#34;Error while parsing input projection.&#34;)

    if not isinstance(target_projection, osr.SpatialReference):
        raise RuntimeError(&#34;Error while parsing target projection.&#34;)

    # The input is already in the correct projection.
    if not copy_if_same and gdal_utils.projections_match(original_projection, target_projection):
        return gdal_utils.get_path_from_dataset(ref)

    src_nodata = metadata[&#34;nodata_value&#34;]
    out_nodata = None
    if dst_nodata == &#34;infer&#34;:
        dst_nodata = src_nodata
    else:
        assert isinstance(dst_nodata, (int, float, type(None))), &#34;dst_nodata must be an int, float, &#39;infer&#39;, or &#39;None&#39;&#34;
        out_nodata = dst_nodata

    if dtype is None:
        dtype = metadata[&#34;datatype&#34;]

    core_utils.remove_if_required(out_path, overwrite)

    reprojected = gdal.Warp(
        out_path,
        ref,
        format=out_format,
        srcSRS=original_projection,
        dstSRS=target_projection,
        resampleAlg=gdal_enums.translate_resample_method(resample_alg),
        outputType=gdal_enums.translate_str_to_gdal_dtype(dtype),
        creationOptions=gdal_utils.default_creation_options(creation_options),
        srcNodata=src_nodata,
        dstNodata=out_nodata,
        multithread=True,
    )

    if reprojected is None:
        raise RuntimeError(f&#34;Error while reprojecting raster: {raster}&#34;)

    return out_path


def reproject_raster(
    raster: Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]],
    projection: Union[int, str, gdal.Dataset, ogr.DataSource, osr.SpatialReference],
    out_path: Optional[Union[str, List[str]]] = None,
    *,
    resample_alg: str = &#34;nearest&#34;,
    copy_if_same: bool = True,
    overwrite: bool = True,
    creation_options: Optional[List[str]] = None,
    dst_nodata: Union[str, int, float] = &#34;infer&#34;,
    dtype: Optional[str] = None,
    prefix: str = &#34;&#34;,
    suffix: str = &#34;&#34;,
    add_uuid: bool = False,
) -&gt; Union[str, List[str]]:
    &#34;&#34;&#34;
    Reproject a raster(s) to a target coordinate reference system.

    Args:
        raster (str/list/gdal.Dataset): The raster(s) to reproject.
        projection (int/str/gdal.Dataset/ogr.DataSource/osr.SpatialReference): The projection is inferred from
            the input. The input can be: WKT proj, EPSG proj, Proj, osr proj, or read
            from a vector or raster datasource either from path or in-memory.

    Keyword Args:
        out_path (str/list/None, default=None): The output path. If not provided, the output path is inferred from the input.
        resample_alg (str, default=&#34;nearest&#34;): The resampling algorithm.
        copy_if_same (bool, default=True): If the input and output projections are the same, copy the input raster to the output path.
        overwrite (bool, default=True): If the output path already exists, overwrite it.
        creation_options (list/None, default=None): A list of creation options for the output raster.
        dst_nodata (str/int/float, default=&#34;infer&#34;): The nodata value for the output raster.
        dtype (str/None, default=None): The data type for the output raster.
        prefix (str, default=&#34;&#34;): The prefix to add to the output path.
        suffix (str, default=&#34;&#34;): The suffix to add to the output path.
        add_uuid (bool, default=False): If True, add a UUID to the output path.

    Returns:
        str/list: The output path(s).
    &#34;&#34;&#34;
    core_utils.type_check(raster, [str, gdal.Dataset, [str, gdal.Dataset]], &#34;raster&#34;)
    core_utils.type_check(projection, [int, str, gdal.Dataset, ogr.DataSource, osr.SpatialReference], &#34;projection&#34;)
    core_utils.type_check(out_path, [list, str, None], &#34;out_path&#34;)
    core_utils.type_check(resample_alg, [str], &#34;resample_alg&#34;)
    core_utils.type_check(overwrite, [bool], &#34;overwrite&#34;)
    core_utils.type_check(creation_options, [[str], None], &#34;creation_options&#34;)
    core_utils.type_check(dst_nodata, [str, int, float], &#34;dst_nodata&#34;)
    core_utils.type_check(dtype, [str, None], &#34;dtype&#34;)
    core_utils.type_check(prefix, [str], &#34;prefix&#34;)
    core_utils.type_check(suffix, [str], &#34;postfix&#34;)
    core_utils.type_check(add_uuid, [bool], &#34;add_uuid&#34;)

    if core_utils.is_str_a_glob(raster):
        raster = core_utils.parse_glob_path(raster)

    raster_list = core_utils.ensure_list(raster)

    assert gdal_utils.is_raster_list(raster_list), f&#34;The input raster(s) contains invalid elements: {raster_list}&#34;

    path_list = gdal_utils.create_output_path_list(
        raster_list,
        out_path=out_path,
        overwrite=overwrite,
        prefix=prefix,
        suffix=suffix,
        add_uuid=add_uuid,
    )

    output = []
    for index, in_raster in enumerate(raster_list):
        output.append(
            _reproject_raster(
                in_raster,
                projection,
                out_path=path_list[index],
                resample_alg=resample_alg,
                copy_if_same=copy_if_same,
                overwrite=overwrite,
                creation_options=creation_options,
                dst_nodata=dst_nodata,
                dtype=dtype,
                prefix=prefix,
                suffix=suffix,
            )
        )

    if isinstance(raster, list):
        return output

    return output[0]


def match_raster_projections(
    rasters: Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]],
    reference: Union[str, gdal.Dataset, ogr.DataSource],
    *,
    out_path: Optional[Union[str, List[str]]] = None,
    overwrite: bool = True,
    dst_nodata: Union[str, int, float] = &#34;infer&#34;,
    copy_if_already_correct: bool = True,
    creation_options: Optional[List[str]] = None,
) -&gt; List[str]:
    &#34;&#34;&#34;
    Match a raster or list of rasters to a master layer. The master can be
    either an OGR layer or a GDAL layer.

    Args:
        rasters (list): A list of rasters to match.
        reference (str/gdal.Dataset/ogr.DataSource): Path to the reference raster
            or vector.

    Keyword Args:
        out_path (str/list, default=None): Paths to the output. If not provided,
            the output will be in-memory rasters.
        overwrite (bool, default=True): If True, existing rasters will be
            overwritten.
        dst_nodata (str, default=&#39;infer&#39;): Value to use for no-data pixels. If not
            provided, the value will be transfered from the original.
        copy_if_already_correct (bool, default=True): If True, the raster will be
            copied if it is already in the correct projection.
        creation_options (list, default=None): List of creation options to pass
            to the output raster.

    Returns:
        list: A list of reprojected input rasters with the correct projection.
    &#34;&#34;&#34;
    core_utils.type_check(rasters, [str, gdal.Dataset, [str, gdal.Dataset]], &#34;rasters&#34;)
    core_utils.type_check(reference, [str, gdal.Dataset, ogr.DataSource], &#34;reference&#34;)
    core_utils.type_check(out_path, [str, list, None], &#34;out_path&#34;)
    core_utils.type_check(overwrite, [bool], &#34;overwrite&#34;)
    core_utils.type_check(dst_nodata, [str, int, float], &#34;dst_nodata&#34;)
    core_utils.type_check(copy_if_already_correct, [bool], &#34;copy_if_already_correct&#34;)
    core_utils.type_check(creation_options, [[str], None], &#34;creation_options&#34;)

    rasters = core_utils.ensure_list(rasters)

    assert gdal_utils.is_raster_list(rasters), &#34;rasters must be a list of rasters.&#34;

    try:
        target_projection = gdal_utils.parse_projection(reference)
    except Exception:
        raise ValueError(f&#34;Unable to parse projection from master. Received: {reference}&#34;) from None

    add_uuid = out_path is None

    path_list = gdal_utils.create_output_path_list(rasters, out_path, overwrite=overwrite, add_uuid=add_uuid, ext=&#34;.tif&#34;)

    output = []

    for index, in_raster in enumerate(rasters):
        path = _reproject_raster(
            in_raster,
            target_projection,
            out_path=path_list[index],
            overwrite=overwrite,
            copy_if_same=copy_if_already_correct,
            dst_nodata=dst_nodata,
            creation_options=gdal_utils.default_creation_options(creation_options),
        )

        output.append(path)

    return output</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="buteo.raster.reproject.find_common_projection"><code class="name flex">
<span>def <span class="ident">find_common_projection</span></span>(<span>rasters: Union[str, osgeo.gdal.Dataset, List[Union[str, osgeo.gdal.Dataset]]])</span>
</code></dt>
<dd>
<div class="desc"><p>Find the common projection of a list of rasters. If no rasters have
the majority of the same projection, the function will return the
projection of the first raster. If only on raster is provided, the
projection of that raster will be returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rasters</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of rasters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>osr.SpatialReference</code></dt>
<dd>The common projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_common_projection(
    rasters: Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]],
):
    &#34;&#34;&#34;
        Find the common projection of a list of rasters. If no rasters have 
        the majority of the same projection, the function will return the
        projection of the first raster. If only on raster is provided, the
        projection of that raster will be returned.
    
        Args:
            rasters (list): A list of rasters.

        Returns:
            osr.SpatialReference: The common projection.
    &#34;&#34;&#34;
    core_utils.type_check(rasters, [str, gdal.Dataset, [str, gdal.Dataset]], &#34;rasters&#34;)

    rasters = core_utils.ensure_list(rasters)

    assert gdal_utils.is_raster_list(rasters), &#34;rasters must be a list of rasters.&#34;

    # Get the projection of each raster
    projections = [gdal_utils.parse_projection(raster) for raster in rasters]

    # Get the most common projection
    common_projection = max(set(projections), key=projections.count)

    return common_projection</code></pre>
</details>
</dd>
<dt id="buteo.raster.reproject.match_raster_projections"><code class="name flex">
<span>def <span class="ident">match_raster_projections</span></span>(<span>rasters: Union[str, osgeo.gdal.Dataset, List[Union[str, osgeo.gdal.Dataset]]], reference: Union[str, osgeo.gdal.Dataset, osgeo.ogr.DataSource], *, out_path: Union[str, List[str], NoneType] = None, overwrite: bool = True, dst_nodata: Union[str, int, float] = 'infer', copy_if_already_correct: bool = True, creation_options: Optional[List[str]] = None) -> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Match a raster or list of rasters to a master layer. The master can be
either an OGR layer or a GDAL layer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rasters</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of rasters to match.</dd>
</dl>
<p>reference (str/gdal.Dataset/ogr.DataSource): Path to the reference raster
or vector.
Keyword Args:
out_path (str/list, default=None): Paths to the output. If not provided,
the output will be in-memory rasters.
overwrite (bool, default=True): If True, existing rasters will be
overwritten.
dst_nodata (str, default='infer'): Value to use for no-data pixels. If not
provided, the value will be transfered from the original.
copy_if_already_correct (bool, default=True): If True, the raster will be
copied if it is already in the correct projection.
creation_options (list, default=None): List of creation options to pass
to the output raster.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of reprojected input rasters with the correct projection.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_raster_projections(
    rasters: Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]],
    reference: Union[str, gdal.Dataset, ogr.DataSource],
    *,
    out_path: Optional[Union[str, List[str]]] = None,
    overwrite: bool = True,
    dst_nodata: Union[str, int, float] = &#34;infer&#34;,
    copy_if_already_correct: bool = True,
    creation_options: Optional[List[str]] = None,
) -&gt; List[str]:
    &#34;&#34;&#34;
    Match a raster or list of rasters to a master layer. The master can be
    either an OGR layer or a GDAL layer.

    Args:
        rasters (list): A list of rasters to match.
        reference (str/gdal.Dataset/ogr.DataSource): Path to the reference raster
            or vector.

    Keyword Args:
        out_path (str/list, default=None): Paths to the output. If not provided,
            the output will be in-memory rasters.
        overwrite (bool, default=True): If True, existing rasters will be
            overwritten.
        dst_nodata (str, default=&#39;infer&#39;): Value to use for no-data pixels. If not
            provided, the value will be transfered from the original.
        copy_if_already_correct (bool, default=True): If True, the raster will be
            copied if it is already in the correct projection.
        creation_options (list, default=None): List of creation options to pass
            to the output raster.

    Returns:
        list: A list of reprojected input rasters with the correct projection.
    &#34;&#34;&#34;
    core_utils.type_check(rasters, [str, gdal.Dataset, [str, gdal.Dataset]], &#34;rasters&#34;)
    core_utils.type_check(reference, [str, gdal.Dataset, ogr.DataSource], &#34;reference&#34;)
    core_utils.type_check(out_path, [str, list, None], &#34;out_path&#34;)
    core_utils.type_check(overwrite, [bool], &#34;overwrite&#34;)
    core_utils.type_check(dst_nodata, [str, int, float], &#34;dst_nodata&#34;)
    core_utils.type_check(copy_if_already_correct, [bool], &#34;copy_if_already_correct&#34;)
    core_utils.type_check(creation_options, [[str], None], &#34;creation_options&#34;)

    rasters = core_utils.ensure_list(rasters)

    assert gdal_utils.is_raster_list(rasters), &#34;rasters must be a list of rasters.&#34;

    try:
        target_projection = gdal_utils.parse_projection(reference)
    except Exception:
        raise ValueError(f&#34;Unable to parse projection from master. Received: {reference}&#34;) from None

    add_uuid = out_path is None

    path_list = gdal_utils.create_output_path_list(rasters, out_path, overwrite=overwrite, add_uuid=add_uuid, ext=&#34;.tif&#34;)

    output = []

    for index, in_raster in enumerate(rasters):
        path = _reproject_raster(
            in_raster,
            target_projection,
            out_path=path_list[index],
            overwrite=overwrite,
            copy_if_same=copy_if_already_correct,
            dst_nodata=dst_nodata,
            creation_options=gdal_utils.default_creation_options(creation_options),
        )

        output.append(path)

    return output</code></pre>
</details>
</dd>
<dt id="buteo.raster.reproject.reproject_raster"><code class="name flex">
<span>def <span class="ident">reproject_raster</span></span>(<span>raster: Union[str, osgeo.gdal.Dataset, List[Union[str, osgeo.gdal.Dataset]]], projection: Union[int, str, osgeo.gdal.Dataset, osgeo.ogr.DataSource, osgeo.osr.SpatialReference], out_path: Union[str, List[str], NoneType] = None, *, resample_alg: str = 'nearest', copy_if_same: bool = True, overwrite: bool = True, creation_options: Optional[List[str]] = None, dst_nodata: Union[str, int, float] = 'infer', dtype: Optional[str] = None, prefix: str = '', suffix: str = '', add_uuid: bool = False) -> Union[str, List[str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Reproject a raster(s) to a target coordinate reference system.</p>
<h2 id="args">Args</h2>
<p>raster (str/list/gdal.Dataset): The raster(s) to reproject.
projection (int/str/gdal.Dataset/ogr.DataSource/osr.SpatialReference): The projection is inferred from
the input. The input can be: WKT proj, EPSG proj, Proj, osr proj, or read
from a vector or raster datasource either from path or in-memory.
Keyword Args:
out_path (str/list/None, default=None): The output path. If not provided, the output path is inferred from the input.
resample_alg (str, default="nearest"): The resampling algorithm.
copy_if_same (bool, default=True): If the input and output projections are the same, copy the input raster to the output path.
overwrite (bool, default=True): If the output path already exists, overwrite it.
creation_options (list/None, default=None): A list of creation options for the output raster.
dst_nodata (str/int/float, default="infer"): The nodata value for the output raster.
dtype (str/None, default=None): The data type for the output raster.
prefix (str, default=""): The prefix to add to the output path.
suffix (str, default=""): The suffix to add to the output path.
add_uuid (bool, default=False): If True, add a UUID to the output path.</p>
<h2 id="returns">Returns</h2>
<p>str/list: The output path(s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reproject_raster(
    raster: Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]],
    projection: Union[int, str, gdal.Dataset, ogr.DataSource, osr.SpatialReference],
    out_path: Optional[Union[str, List[str]]] = None,
    *,
    resample_alg: str = &#34;nearest&#34;,
    copy_if_same: bool = True,
    overwrite: bool = True,
    creation_options: Optional[List[str]] = None,
    dst_nodata: Union[str, int, float] = &#34;infer&#34;,
    dtype: Optional[str] = None,
    prefix: str = &#34;&#34;,
    suffix: str = &#34;&#34;,
    add_uuid: bool = False,
) -&gt; Union[str, List[str]]:
    &#34;&#34;&#34;
    Reproject a raster(s) to a target coordinate reference system.

    Args:
        raster (str/list/gdal.Dataset): The raster(s) to reproject.
        projection (int/str/gdal.Dataset/ogr.DataSource/osr.SpatialReference): The projection is inferred from
            the input. The input can be: WKT proj, EPSG proj, Proj, osr proj, or read
            from a vector or raster datasource either from path or in-memory.

    Keyword Args:
        out_path (str/list/None, default=None): The output path. If not provided, the output path is inferred from the input.
        resample_alg (str, default=&#34;nearest&#34;): The resampling algorithm.
        copy_if_same (bool, default=True): If the input and output projections are the same, copy the input raster to the output path.
        overwrite (bool, default=True): If the output path already exists, overwrite it.
        creation_options (list/None, default=None): A list of creation options for the output raster.
        dst_nodata (str/int/float, default=&#34;infer&#34;): The nodata value for the output raster.
        dtype (str/None, default=None): The data type for the output raster.
        prefix (str, default=&#34;&#34;): The prefix to add to the output path.
        suffix (str, default=&#34;&#34;): The suffix to add to the output path.
        add_uuid (bool, default=False): If True, add a UUID to the output path.

    Returns:
        str/list: The output path(s).
    &#34;&#34;&#34;
    core_utils.type_check(raster, [str, gdal.Dataset, [str, gdal.Dataset]], &#34;raster&#34;)
    core_utils.type_check(projection, [int, str, gdal.Dataset, ogr.DataSource, osr.SpatialReference], &#34;projection&#34;)
    core_utils.type_check(out_path, [list, str, None], &#34;out_path&#34;)
    core_utils.type_check(resample_alg, [str], &#34;resample_alg&#34;)
    core_utils.type_check(overwrite, [bool], &#34;overwrite&#34;)
    core_utils.type_check(creation_options, [[str], None], &#34;creation_options&#34;)
    core_utils.type_check(dst_nodata, [str, int, float], &#34;dst_nodata&#34;)
    core_utils.type_check(dtype, [str, None], &#34;dtype&#34;)
    core_utils.type_check(prefix, [str], &#34;prefix&#34;)
    core_utils.type_check(suffix, [str], &#34;postfix&#34;)
    core_utils.type_check(add_uuid, [bool], &#34;add_uuid&#34;)

    if core_utils.is_str_a_glob(raster):
        raster = core_utils.parse_glob_path(raster)

    raster_list = core_utils.ensure_list(raster)

    assert gdal_utils.is_raster_list(raster_list), f&#34;The input raster(s) contains invalid elements: {raster_list}&#34;

    path_list = gdal_utils.create_output_path_list(
        raster_list,
        out_path=out_path,
        overwrite=overwrite,
        prefix=prefix,
        suffix=suffix,
        add_uuid=add_uuid,
    )

    output = []
    for index, in_raster in enumerate(raster_list):
        output.append(
            _reproject_raster(
                in_raster,
                projection,
                out_path=path_list[index],
                resample_alg=resample_alg,
                copy_if_same=copy_if_same,
                overwrite=overwrite,
                creation_options=creation_options,
                dst_nodata=dst_nodata,
                dtype=dtype,
                prefix=prefix,
                suffix=suffix,
            )
        )

    if isinstance(raster, list):
        return output

    return output[0]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#reproject-rasters">Reproject rasters.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="buteo.raster" href="index.html">buteo.raster</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="buteo.raster.reproject.find_common_projection" href="#buteo.raster.reproject.find_common_projection">find_common_projection</a></code></li>
<li><code><a title="buteo.raster.reproject.match_raster_projections" href="#buteo.raster.reproject.match_raster_projections">match_raster_projections</a></code></li>
<li><code><a title="buteo.raster.reproject.reproject_raster" href="#buteo.raster.reproject.reproject_raster">reproject_raster</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>